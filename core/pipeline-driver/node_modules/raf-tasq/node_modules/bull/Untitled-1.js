/*eslint-env node */
'use strict';

//
// This code will be called everytime a job is going to be processed if the job has a repeat option. (from delay -> active).
//
var _ = require('lodash');
var parser = require('cron-parser');
var Job = require('./job');

function nextJob(queue, name, data, opts, isRepeat){
  console.error(name, data, opts, isRepeat);
  var repeat = opts.repeat;
  if(!isRepeat && opts.jobId){
    opts.repeat.jobId = opts.jobId;
  }
  var repeatJobId = opts.repeat.jobId ? opts.repeat.jobId + ':' : '';
  var repeatKey = name + ':' + repeatJobId + repeat.cron;

  //
  // Get millis for this repeatable job.
  // Only use `millis` from the `repeatKey` when the job is a repeat, otherwise, we want
  // `Date.now()` to ensure we try to add the next iteration only
  //
  return getOrAddMillis(queue, repeatKey, isRepeat).then(function(millis){
    console.error('wht=?', millis);

    var interval = parser.parseExpression(repeat.cron, _.defaults({
      currentDate: new Date(millis)
    }, repeat));
    var nextMillis;
    try{
      nextMillis = interval.next();
    } catch(e){
      // Ignore error
    }

    if(nextMillis){
      nextMillis = nextMillis.getTime();
      var delay = nextMillis - Date.now();

      //
      // Generate unique job id for this iteration.
      //
      var customId = 'repeat:' + name + ':' + repeatJobId + nextMillis;

      //
      // Set key and add job should be atomic.
      //
      return queue.client.zadd(queue.toKey('repeat'), nextMillis, repeatKey).then(function(){
        return Job.create(queue, name, data, _.extend(_.clone(opts), {
          jobId: customId,
          delay: delay < 0 ? 0 : delay,
          timestamp: Date.now()
        }));
      });
    }
  });
};

function getOrAddMillis(queue, repeatKey, isRepeat){
  if(isRepeat){
    return queue.client.zscore(queue.toKey('repeat'), repeatKey);
  }else {
    var millis = Date.now();
    return queue.client.zadd(queue.toKey('repeat'), millis, repeatKey).then(function(){
      return millis;
    });
  }
}

//
// INVESTIGATE: Seems to be a race condition if two workers add the same repeat job at the same time.
// Both could call zscore and get null, both would try to add a repeat key, the last one will overwrite
// the previous key, but both will succeed creating a new Job, making the job execute twice in this case.
// Solution seems to have a lua script that gets or sets the zscore.
module.exports.nextJob = nextJob;