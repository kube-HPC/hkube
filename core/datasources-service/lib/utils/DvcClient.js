const fse = require('fs-extra');
const yaml = require('js-yaml');
const Shell = require('./Shell');

/** @typedef {import('./types').DvcContent} DvcContent */
class DvcClient {
    constructor(cwd, repositoryUrl, storageName = 'storage') {
        this.cwd = cwd;
        this.repositoryUrl = repositoryUrl;
        this._shell = Shell(cwd);
        this.storageName = storageName;
        this._execute = (...args) => this._shell('dvc', args.flat());
    }

    init() {
        return this._execute('init');
    }

    config(config) {
        return fse.writeFile(`${this.cwd}/.dvc/config.local`, config);
    }

    /**
     * Creates .dvc files, updates the respective .gitignore file. **NOTE**: in
     * case of an *update*, if any data was stored on the .dvc file it will be deleted!
     *
     * @param {string[]} filePaths
     */
    add(filePaths) {
        return this._execute('add', filePaths);
    }

    /** @param {{ path?: string; paths?: string[] }} props */
    remove({ path, paths }) {
        if (path) return this._execute('remove', `${path}.dvc`);
        if (paths) {
            return this._execute(
                'remove',
                paths.map(p => `${p}.dvc`)
            );
        }
        throw new Error('you did not provide a path or paths to delete');
    }

    /** @param {string=} storageName */
    push(storageName) {
        return this._execute('push', '-r', storageName || this.storageName);
    }

    /** @param {string[]=} filePaths */
    pull(filePaths = []) {
        return filePaths.length > 0
            ? typeof filePaths === 'string'
                ? this._execute('pull', filePaths)
                : this._execute('pull', ...filePaths)
            : this._execute('pull');
    }

    /**
     * Moves .dvc files and updates gitignore
     *
     * @param {string} srcPath
     * @param {string} targetPath
     */
    move(srcPath, targetPath) {
        return this._execute('move', srcPath, targetPath);
    }

    /**
     * Add the payload to the .dvc file under the specified root field. appends
     * a hash to the payload to ensure the hash generated by dvc has changed
     * before updating the .dvc
     *
     * @param {string} filePath
     * @param {DvcContent} dvcContent
     * @param {string} rootField
     * @param {object} payload
     */
    async enrichMeta(filePath, dvcContent, rootField, payload) {
        const dvcFilePath = `${this.cwd}/${filePath.replace(/.dvc$/, '')}.dvc`;
        const { meta = {} } = dvcContent;
        const dvcHash = dvcContent.outs[0].md5;
        const extendedData = {
            ...dvcContent,
            meta: {
                ...meta,
                [rootField]: { ...payload, hash: dvcHash },
            },
        };
        const yamlDump = yaml.dump(extendedData, {
            indent: 2,
            noArrayIndent: true,
        });
        return fse.writeFile(dvcFilePath, yamlDump);
    }

    /** @returns {Promise<DvcContent>} */
    async loadDvcContent(filePath) {
        const dvcFilePath = `${this.cwd}/${filePath.replace(/.dvc$/, '')}.dvc`;
        const stringifiedContent = await fse.readFile(dvcFilePath);
        // @ts-ignore
        return yaml.load(stringifiedContent.toString());
    }
}

module.exports = DvcClient;
